# key의 존재 유무에 따른 업데이트 방식

왜 배열을 렌더링 할 때 key가 없다는 에러가 뜰까?

예를 들어 다음과 같은 배열이 있다고 가정해보자

```javascript
const array = ["a", "b", "c", "d"]
```

그리고 위 배열을 다음과 같이 렌더링한다고 가정해보자 !

```javascript
array.map((item) => <div>{item}</div>)
```

위 배열의 b와 c사이에 z를 삽입하게 된다면, 리렌더링을 하게 될 때 `<div>b</div>`와 `<div>c</div>` 사이에 새로운 `<div>`태그를 삽입을 하게 되는 것이 아니라, 기존의 c가 z로 바뀌고, d는 c로 바뀌고, 맨 마지막에 d가 새로 삽입이 된다.

그 다음에 a를 제거하게 된다면, 기존의 a가 b로 바뀌고, b는 z로 바뀌고, z는 c로 바뀌고, c는 a로 바뀌고, 맨 마지막에 있는 d가 제거된다.

비효율적이다. 하지만 `key`가 있다면 이 작업은 개선된다.

만약 객체에 key가 있고 다음과 같이 렌더링이 된다면

```javascript
array.map((item) => <div key={item.id}>{item.text}</div>)
```

배열이 업데이트 될때 `key`가 없을 때 처럼 비효율적으로 업데이트 하는 것이 아니라, 수정되지 않는 기존의 값은 그대로 두고 원하는 곳에 내용을 삽입하거나 삭제한다.
때문에 배열을 렌더링 할 때에는 고유한 `key`값이 있는 것이 중요하며 만약에 배열안에 중복되는 `key`값이 있을 때에는 렌더링시에 오류메시지가 콘솔에 나타나게 되며, 업데이트가 제대로 이루어지지 않게 된다.

# useRef로 컴포넌트 안의 변수 만들기

컴포넌트에서 특정 DOM을 선택해야 할 때, `ref`를 사용해야 한다고 배웠다. 그리고 함수형 컴포넌트에서 이를 설정할 때 `useRef`를 사용하여 설정한다고 배웠다.

`useRef`Hook은 DOM을 선택하는 용도 외에도, 다른 용도가 한가지 더 있는데 바로 컴포넌트 안에서 조회 및 수정 할 수 있는 변수를 관리하는 것이다.

`useRef`로 관리하는 변수는 값이 바뀐다고 해서 컴포넌트가 리렌더링되지 않는다. 리액트 컴포넌트에서의 상태는 상태를 바꾸는 함수를 호출하고 나서 그 다음 렌더링 이후로 업데이트 된 상태를 조회 할 수 있는 반면, `useRef`로 관리하고 있는 변수는 설정 후 바로 조회할 수 있다.

이 변수를 사용하여 다음과 같은 값을 관리할 수 있다.

- `setTimeout`, `setInterval`을 통해 만들어진 id
- 외부 라이브러리를 사용하여 생성된 인스턴스
- scroll 위치
